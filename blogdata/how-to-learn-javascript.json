{
    "title":"How-to-Learn-JavaScript",
    "author":"Faizan Malik",
    "content": "<h2>&nbsp;<\/h2>\r\n\r\n<p>JavaScript classes bring the addition of&nbsp;<code>set<\/code>&nbsp;and&nbsp;<code>get<\/code>&nbsp;keywords to define behaviour when setting and getting property values.<\/p>\r\n\r\n<p>I&rsquo;d like to share a state management pattern I&rsquo;ve been using that keeps code private, encapsulated, and easy to manage.<\/p>\r\n\r\n<p>If you&rsquo;ve not yet explored the world of setters and getters, also known as &ldquo;accessors&rdquo; then this post will (hopefully) blow your mind a little.<\/p>\r\n\r\n<p>Previously, I wrote about&nbsp;<a href=\"https:\/\/ultimatecourses.com\/blog\/private-properties-methods-javascript-classes\">private properties and methods<\/a>&nbsp;and how to get it setup with Babel - in this article we&rsquo;ll take things a little further.<\/p>\r\n\r\n<p>Let&rsquo;s take a&nbsp;<code>class<\/code>&nbsp;example, without private properties or setters:<\/p>\r\n\r\n<pre>\r\n<code>class Cart {\r\n  constructor(items = []) {\r\n    this._items = items;\r\n  }\r\n  get value() {\r\n    return this._items;\r\n  }\r\n  get count() {\r\n    return this._items.length;\r\n  }\r\n  add(item) {\r\n    this._items = [...this.value, item];\r\n  }\r\n  remove(id) {\r\n    this._items = this.value.filter((item) =&gt; item.id !== id);\r\n  }\r\n}\r\n<\/code><\/pre>\r\n\r\n<p>This works just fine, but leads us to a big issue.<\/p>\r\n\r\n<p>Our&nbsp;<code>get value() {}<\/code>&nbsp;is the intended way for developers to interact with our code, but it still leaves the&nbsp;<code>this._items<\/code>&nbsp;property fully open to access and manipulation:<\/p>\r\n\r\n<pre>\r\n<code>const cart = new Cart();\r\n\r\nconst burger = { id: '\uD83C\uDF54', name: 'Big Burger', price: 499 };\r\ncart.add(burger);\r\n\r\nconsole.log(cart.value); \/\/ \u2705 Getter returns this._items [{...}]\r\nconsole.log(cart._items); \/\/ \u274C this._items publicly accessible [{...}]\r\n<\/code><\/pre>\r\n\r\n<blockquote>\r\n<p>The naming convention with an underscore is a traditional way to infer that a property is private and shouldn&rsquo;t be modified or referenced. But this has no effect on whether the data is public or not, so it leaves the data open and vulnerable.<\/p>\r\n<\/blockquote>\r\n\r\n<p>Do we want to expose that data? Probably not.<\/p>\r\n\r\n<p>Inspecting our&nbsp;<code>Cart<\/code>&nbsp;class, it gives us:<\/p>\r\n\r\n<pre>\r\n<code>Cart {\r\n  _items: [{...}],\r\n  value: [{...}],\r\n  count: 1,\r\n  prototype: { add: \u0192, remove: \u0192 }\r\n}\r\n<\/code><\/pre>\r\n\r\n<p>Note the&nbsp;<code>_items<\/code>&nbsp;property, this is where the &lsquo;raw data&rsquo; is kept.<\/p>\r\n\r\n<p>The&nbsp;<code>value<\/code>&nbsp;getter allows us to transform it on the way out, which we&rsquo;ll cover shortly.<\/p>\r\n\r\n<p>&hellip;So, what can we do?<\/p>\r\n\r\n<p>Let&rsquo;s introduce a private&nbsp;<code>#items<\/code>&nbsp;property to hold our &lsquo;state&rsquo;:<\/p>\r\n\r\n<pre>\r\n<code>class Cart {\r\n  #items;\r\n  constructor(items = []) {\r\n    this.#items = items;\r\n  }\r\n  get value() {\r\n    return this.#items;\r\n  }\r\n  get count() {\r\n    return this.#items.length;\r\n  }\r\n  add(item) {\r\n    this.#items = [...this.value, item];\r\n  }\r\n  remove(id) {\r\n    this.#items = this.value.filter((item) =&gt; item.id !== id);\r\n  }\r\n}\r\n<\/code><\/pre>\r\n\r\n<p>Now we don&rsquo;t see&nbsp;<code>_items<\/code>&nbsp;or&nbsp;<code>#items<\/code>, it is completely private and hidden:<\/p>\r\n\r\n<pre>\r\n<code>Cart {\r\n  value: [{...}],\r\n  count: 1,\r\n  prototype: { add: \u0192, remove: \u0192 }\r\n}\r\n<\/code><\/pre>\r\n\r\n<p>That&rsquo;s the first task out the way, encapsulating and maintaining state with a private property. Safety first!<\/p>\r\n\r\n<p>But what about an even better way to set the value instead of communicating directly to the&nbsp;<code>this.#items<\/code>&nbsp;property?<\/p>\r\n\r\n<p>This is an optional choice, but a personal preference.<\/p>\r\n\r\n<p>Let&rsquo;s use a&nbsp;<code>set value() {}<\/code>&nbsp;and then write all values to the&nbsp;<code>this.#items<\/code>&nbsp;property:<\/p>\r\n\r\n<pre>\r\n<code>class Cart {\r\n  #items;\r\n  constructor(items = []) {\r\n    this.value = items;\r\n  }\r\n  set value(items) {\r\n    this.#items = items;\r\n  }\r\n  get value() {\r\n    return this.#items;\r\n  }\r\n  get count() {\r\n    return this.value.length;\r\n  }\r\n  add(item) {\r\n    this.value = [...this.value, item];\r\n  }\r\n  remove(id) {\r\n    this.value = this.value.filter((item) =&gt; item.id !== id);\r\n  }\r\n}\r\n<\/code><\/pre>\r\n\r\n<p>Notice&nbsp;<code>this.value<\/code>&nbsp;is now referenced everywhere inside the class. It feels more complete and clear to me.<\/p>\r\n\r\n<p>In this example, it might not be completely necessary, but I think in a bigger project with more complex functionality using a setter here keeps things contained in one place.<\/p>\r\n\r\n<p>But we&rsquo;re not done just yet, I want to ensure that our&nbsp;<code>this.value<\/code>&nbsp;cannot be tampered with on the outside.<\/p>\r\n\r\n<p>Let&rsquo;s introduce&nbsp;<code>Object.freeze()<\/code>&nbsp;and freeze our data structure when setting the value to prevent mutations:<\/p>\r\n\r\n<pre>\r\n<code>class Cart {\r\n  #items;\r\n  constructor(items = []) {\r\n    this.value = items;\r\n  }\r\n  set value(items) {\r\n    this.#items = Object.freeze(this.#items);\r\n  }\r\n  get value() {\r\n    return this.#items;\r\n  }\r\n  \/\/ ...\r\n}\r\n<\/code><\/pre>\r\n\r\n<p>Now if we try to use methods like&nbsp;<code>[].push()<\/code>&nbsp;or direct mutations, it will not work:<\/p>\r\n\r\n<pre>\r\n<code>const cart = new Cart();\r\n\r\nconst burger = { id: '\uD83C\uDF54', name: 'Big Burger', price: 499 };\r\n\r\n\/\/ \u2705 Works as intended...\r\ncart.add(burger);\r\n\u274C \/\/ Uncaught TypeError: Cannot add property 1, object is not extensible\r\ncart.value.push(burger);\r\n\u274C \/\/ Error: Cannot assign to read only property 0 of object [object Array]\r\ncart.value[0] = burger;\r\n<\/code><\/pre>\r\n\r\n<blockquote>\r\n<p>As we set&nbsp;<code>this.#items<\/code>&nbsp;as frozen on the way in, when we&nbsp;<code>get<\/code>&nbsp;the value it&rsquo;s still frozen.<\/p>\r\n<\/blockquote>\r\n\r\n<p>So, that&rsquo;s my approach to handling private state alongside frozen state. It helps enforce immutability and creates a clean pattern within the class.<\/p>\r\n\r\n<p>We even get the additional benefit inside the&nbsp;<code>constructor<\/code>&nbsp;as we use&nbsp;<code>this.value = items<\/code>&nbsp;which sets the initial value as frozen too.<\/p>\r\n\r\n<p>Another cool trick, you can check if an object is frozen by using&nbsp;<code>Object.isFrozen()<\/code>:<\/p>\r\n\r\n<pre>\r\n<code>const cart = new Cart([]);\r\n\r\n\/\/ \u2705 true\r\nconsole.log(Object.isFrozen(cart.value));\r\n<\/code><\/pre>\r\n\r\n<p>This approach is also great because it enforces us to use immutable operations within the class, things like&nbsp;<code>.filter()<\/code>&nbsp;are being used and the spread operator to copy or create new values.<\/p>\r\n\r\n<p>Happy setting and getting!<\/p>\r\n\r\n<p>&nbsp;<\/p>\r\n",
    "slug":"how-to-learn-javaScript"
}