{
    "title":"How-to-Learn-Cryptocurrency",
    "author":"Faizan Malik",
    "content": "<p>When Bitcoin (BTC) first appeared in 2009, few people had a clear idea of what it was, let alone the waves it would generate both financially and technologically. The underlying blockchain technology was more or less a new concept, and like most new concepts was poorly understood in general. In 2018, blockchain remains a hot topic: while it is tied in many people&rsquo;s minds to cryptocurrencies, it is actually a standalone concept on which cryptocurrencies can be based. This article will clarify how blockchains work and, just as importantly, where blockchain ends and technologies based on it begin.<\/p>\r\n\r\n<p>This post is an updated and expanded version of our&nbsp;<a href=\"https:\/\/www.forcepoint.com\/blog\/security-labs\/bitcoin-other-cryptocurrencies\">2017 cryptocurrency primer<\/a>.<\/p>\r\n\r\n<h2>Blockchain<\/h2>\r\n\r\n<h3>What Is Blockchain and What Does it Look Like?<\/h3>\r\n\r\n<p>The purpose of blockchain is to create a ledger; that is, a record of historical transactions (be those financial transactions, messages, etc.).<\/p>\r\n\r\n<p>Fundamentally, the blockchain is aptly named: it is a chain of blocks of data which at their most basic level (at least in most current implementations) can be conceptualised as something similar to the diagram below, which is based on the blockchain as famously implemented by Bitcoin.<\/p>\r\n\r\n<p><img alt=\"\" src=\"https:\/\/www.forcepoint.com\/sites\/default\/files\/blog\/legacy\/u1121\/201804_miner1_blockchain.png\" \/><\/p>\r\n\r\n<p>Any given block of data in this implementation contains four pieces of information:<\/p>\r\n\r\n<p><strong>Timestamp&nbsp;<\/strong>&ndash; The time at which the block was created.<\/p>\r\n\r\n<p><strong>Transaction Root<\/strong>&nbsp;&ndash; The details of the transactions contained in this block &ndash; i.e. this section of the ledger. The amount of data held in this section can vary significantly: in Bitcoin, it will be approximately ten minutes&rsquo; worth of transactions. Other implementations use shorter windows.<\/p>\r\n\r\n<p><strong>Previous Hash<\/strong>&nbsp;&ndash; The&nbsp;<a href=\"https:\/\/en.wikipedia.org\/wiki\/Cryptographic_hash_function\" target=\"_blank\">hash<\/a>&nbsp;of the last block in the chain &ndash; this is how the chain is linked together. When any given block has been processed, its hash becomes the Previous Hash of the next block in the chain, thus allowing historical records to be linked together and traversed.<\/p>\r\n\r\n<p><strong>Nonce&nbsp;<\/strong>&ndash; A&nbsp;<a href=\"https:\/\/en.wikipedia.org\/wiki\/Cryptographic_nonce\" target=\"_blank\">cryptographic term<\/a>&nbsp;referring to an arbitrary value used only once in a transaction. The purpose of this will be discussed in more detail later on.<\/p>\r\n\r\n<p>The hash of the block &ndash; which becomes the Previous Hash value in the following block &ndash; is the hashed value of all the data held in these four chunks taken together.<\/p>\r\n\r\n<h3>Is blockchain tamper-proof?<\/h3>\r\n\r\n<p>Perhaps a truism of security is that nothing is inherently tamper-proof: it has to be designed to make tampering difficult and then protected by as many anti-tampering controls as possible. It shouldn&rsquo;t, therefore, come as a surprise that blockchains are not themselves tamper-proof without some additional controls.<\/p>\r\n\r\n<p>The first of these controls is distribution and decentralisation: by ensuring that all interested parties have access to the ledger and any new transactions which are supposed to be added to it, tampering should become much more evident. If all of the parties involved have access to the same information, an attempt by anything less than a majority of stakeholders to incorrectly report a transaction will be noticed by all of the other parties who are processing the data honestly.<\/p>\r\n\r\n<p>Without distribution and decentralisation &ndash; and therefore equal access to data for all interested parties &ndash; blockchain is no more tamper proof than any other data storage mechanism. A blockchain owned and exclusively processed by one individual, regardless of how many nodes they operate and how many people can read the data stored in the blockchain, could be tampered with by virtue of the fact that one individual controls all of the processing.<\/p>\r\n\r\n<p>At this point, we need a method whereby the interested parties can communicate with each other and check the validity of a new block submitted to the chain. This is where implementations diverge. Historically, there have been three common approaches:<\/p>\r\n\r\n<p><strong>Proof of Work<\/strong>&nbsp;&ndash; Make calculating a valid hash for a block difficult to do, but easy for other parties to verify. The first person to calculate a valid hash submits it to the network and it is validated by the other parties prior to adding it to their chain.<br \/>\r\nWell-Known Uses: Bitcoin (cryptocurrency); Monero (cryptocurrency)<\/p>\r\n\r\n<p><strong>Proof of Stake<\/strong>&nbsp;&ndash; Block creators are determined pseudo-randomly based on their &lsquo;stake&rsquo; in the blockchain. This is primarily used by cryptocurrencies as the stake is easily calculated based on the amount of currency held by each member.<br \/>\r\nWell-Known Uses: DASH (cryptocurrency); Ethereum (cryptocurrency, hybrid PoS\/PoW)<\/p>\r\n\r\n<p><strong>Practical Byzantine Fault Tolerance<\/strong>&nbsp;&ndash; Something of a mouthful, PBFT is a consensus-based method of &lsquo;tolerating&rsquo; faults in the data and recovering automatically. The specifics of the system are beyond the scope of this article.<br \/>\r\nWell-Known Uses:&nbsp;<a href=\"https:\/\/en.wikipedia.org\/wiki\/Hyperledger\" target=\"_blank\">Hyperledger Fabric<\/a><\/p>\r\n\r\n<p>As an aside: all of the above are solutions to the risk of what is known as a&nbsp;<a href=\"https:\/\/en.wikipedia.org\/wiki\/Byzantine_fault_tolerance\">Byzantine Fault<\/a>&nbsp;&ndash; that is, a fault where there is potentially imperfect or incomplete information which may result in the fault presenting differently to the various parties involved (consider that each party doesn&rsquo;t know if or how many malicious participants there are and that some of these, while &lsquo;in&rsquo; on any scheme to falsify data may only be malicious &lsquo;approvers&rsquo; of bad data, not generators of it).<\/p>\r\n\r\n<h3>Is it time to talk about mining yet?<\/h3>\r\n\r\n<p>Yes and no.<\/p>\r\n\r\n<p>Yes, because we already have: mining is Proof of Work.<\/p>\r\n\r\n<p>No, because mining is really an artefact of cryptocurrencies using the Proof of Work fault tolerance solution and not generally desirable for the majority of other blockchain applications.<\/p>\r\n\r\n<h3>How do you prove work?<\/h3>\r\n\r\n<p>Proof of Work functions rely on setting a &lsquo;difficulty target&rsquo; for the hash: you set some sort of numerical goal which the hash has to meet. As hashes will always be the same for the same set of data, we need to change some value which makes up the data being hashed to try and manipulate the hash value &ndash; this is where we use the nonce.<\/p>\r\n\r\n<p>Take a look at the diagram below, which borrows from the example on the en.bitcoin.it wiki:<\/p>\r\n\r\n<p><img alt=\"\" src=\"https:\/\/www.forcepoint.com\/sites\/default\/files\/blog\/legacy\/u1121\/201804_miner1_pow.png\" \/><\/p>\r\n\r\n<p>Let&rsquo;s simplify all of the data held in the Previous Hash, Timestamp, and Transaction Root elements to the text &lsquo;Hello, world!&rsquo; &ndash; shown in red on both the left and right side of the diagram.<\/p>\r\n\r\n<p>Let&rsquo;s also set an arbitrary difficulty target which states that the hash must start with four zeroes.<\/p>\r\n\r\n<p>To achieve this, we start concatenating an arbitrary piece of data &ndash; the nonce, shown in blue &ndash; to the data we want to record and then hashing the entire string. If that doesn&rsquo;t meet our difficulty target, we add a different nonce on to the original data we wanted to record and try again.<\/p>\r\n\r\n<p>In this case, to hash &lsquo;Hello, world!&rsquo; so that it meets our &lsquo;four zeroes&rsquo; difficulty target we will need to iterate 4,250 times. In the real world, this would then be sent to the network who can then validate our effort very quickly by checking just the value we&rsquo;ve sent and comparing the hash to the difficulty target &ndash; remember that all of the people checking should have a copy of the same data as is shown in red above, so if we&rsquo;ve cheated and used falsified data to generate our hash, they&rsquo;ll get a different one to us.<\/p>\r\n\r\n<p>This may sound a lot like &#39;brute forcing&#39; something, and that&rsquo;s because it is. However, because it&rsquo;s quick to check that the work has been done legitimately it means that the network can easily verify and reject results with which it doesn&rsquo;t agree.<\/p>\r\n\r\n<h2>Cryptocurrencies<\/h2>\r\n\r\n<p>First and foremost, try to think of cryptocurrencies as applications which use blockchains for storage. Equally, remember that cryptocurrencies could conceivably be based on any of the above fault tolerance approaches: Proof of Work, Proof of Stake, or PBFT although in reality all major implementations are either PoW or PoS based at the time of writing.<\/p>\r\n\r\n<h3>We can talk about mining now<\/h3>\r\n\r\n<p>As we previously discussed, certain currencies being minable is a result of their use of Proof of Work fault tolerance. As an inducement to perform the intensive calculations required by the PoW approach, the first person to successfully generate a valid hash first which is subsequently accepted by the network is rewarded with either the transaction fees included in that block (generally the pieces of a single &lsquo;coin&rsquo; included in a transaction after a certain number of decimal places) and\/or a new coin in the currency.<\/p>\r\n\r\n<p>Unsurprisingly, this resulted in a rush to mine these currencies and, as with anything where money is involved, a rush to develop better and faster ways of mining. In Bitcoin&rsquo;s case, this resulted in the development of Application Specific Integrated Circuits (ASICs) dedicated to mining, resulting in hash rates of over&nbsp;<a href=\"https:\/\/blockchain.info\/charts\/hash-rate\" target=\"_blank\">30,000,000 terahashes per second<\/a>&nbsp;in April 2018. That&rsquo;s 30 quintillion hashes per second across the whole network.<\/p>\r\n\r\n<p>To compensate for this, the Bitcoin network&nbsp;<a href=\"https:\/\/blockchain.info\/charts\/difficulty\" target=\"_blank\">adjusts the difficulty rate<\/a>&nbsp;to result in a new block being &lsquo;mined&rsquo; every ten minutes. Keep in mind that different PoW-based currencies frequently have different target times for blocks.<\/p>\r\n\r\n<p>This huge hashing rate quickly made using anything other than specialised hardware massively inefficient (to the point where you&rsquo;d likely make a loss on the electricity used). The following table was again compiled from data on&nbsp;<a href=\"https:\/\/en.bitcoin.it\/wiki\/Mining_hardware_comparison\" target=\"_blank\">en.bitcoin.it\/wiki<\/a>&nbsp;and&nbsp;<a href=\"https:\/\/shop.bitmain.com\/antminer_t9_asic_bitcoin_miner.htm\">manufacturer specifications<\/a>:<\/p>\r\n\r\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\">\r\n\t<thead>\r\n\t\t<tr>\r\n\t\t\t<th scope=\"col\">Hardware<\/th>\r\n\t\t\t<th scope=\"col\">Joules\/gigahash<\/th>\r\n\t\t<\/tr>\r\n\t<\/thead>\r\n\t<tbody>\r\n\t\t<tr>\r\n\t\t\t<td>2017 Antminer T9 ASIC<\/td>\r\n\t\t\t<td>0.126<\/td>\r\n\t\t<\/tr>\r\n\t\t<tr>\r\n\t\t\t<td>2013 AMD 7870 XT GPU<\/td>\r\n\t\t\t<td>326.8<\/td>\r\n\t\t<\/tr>\r\n\t\t<tr>\r\n\t\t\t<td>2011 Intel Core i5<\/td>\r\n\t\t\t<td>~20,000<\/td>\r\n\t\t<\/tr>\r\n\t<\/tbody>\r\n<\/table>\r\n\r\n<p><em>Note: The 2013 AMD 7870XT is the fastest, most recent GPU for which anyone has submitted a Bitcoin hashing benchmark.<\/em><\/p>\r\n\r\n<p>As a result of this arms race, implementations diverge once again. This time with some cryptocurrencies branching off to use a different type of Proof of Work algorithm. Broadly, these can be categorised as:<\/p>\r\n\r\n<p><strong>CPU-Constrained Algorithms<\/strong>&nbsp;&ndash; These are algorithms such as SHA256 (as used by Bitcoin) which require very little memory per instance (&lt; 512 bytes) and are therefore easily performed by cheaply-made ASICs.<br \/>\r\nWell-Known Uses: Bitcoin (SHA256)<\/p>\r\n\r\n<p><strong>Memory-Constrained Algorithms<\/strong>&nbsp;&ndash; Algorithms which require significantly more memory per instance and therefore significantly increase the cost and effort involved in ASIC development.<br \/>\r\nWell-Known Uses: Litecoin (Scrypt); Monero (CryptoNight)<\/p>\r\n\r\n<blockquote>\r\n<p>&nbsp;<\/p>\r\n<\/blockquote>\r\n",
    "slug":"how-to-learn-cryptocurrency"
}